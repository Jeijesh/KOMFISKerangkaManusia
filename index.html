<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kerangka 3D Interaktif</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
<style>
body {
  margin: 0;
  font-family: 'Fredoka', Arial, sans-serif;
  display: flex;
  flex-direction: column;
  height: 100vh;
  background: linear-gradient(135deg, rgba(84,141,255,0.35), rgba(255,183,77,0.25)) no-repeat fixed, url('./background.png') no-repeat center center fixed;
  background-size: cover;
}

/* Main Content Container */
#main-container {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* Sidebar Categories */
#sidebar {
  width: 280px;
  background: linear-gradient(180deg, rgba(29,41,77,0.95), rgba(33,64,95,0.9));
  color: #fff;
  padding: 20px;
  overflow-y: auto;
  box-shadow: 4px 0 20px rgba(0,0,0,0.25);
}

#sidebar h3 {
  margin: 0 0 16px;
  color: #ffd166;
  display: flex;
  align-items: center;
  gap: 8px;
}

#search-box {
  width: 100%;
  padding: 10px 12px;
  border: none;
  border-radius: 20px;
  background: rgba(255,255,255,0.1);
  color: #fff;
  margin-bottom: 20px;
  font-family: 'Fredoka', Arial, sans-serif;
}

#search-box::placeholder {
  color: rgba(255,255,255,0.6);
}

.category-group {
  margin-bottom: 24px;
}

.category-title {
  font-weight: 600;
  margin-bottom: 8px;
  color: #ffd166;
  font-size: 1.1em;
}

.bone-list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.bone-item {
  padding: 8px 12px;
  margin: 4px 0;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  background: rgba(255,255,255,0.05);
  display: flex;
  align-items: center;
  gap: 8px;
}

.bone-item:hover {
  background: rgba(255,255,255,0.15);
  transform: translateX(4px);
}

.bone-item.active {
  background: linear-gradient(90deg, #ffd166, #ffb347);
  color: #102a43;
  font-weight: 600;
}

/* Container kiri untuk 3D - sekarang full width */
#canvas-container {
  flex: 1;
  position: relative;
  overflow: hidden;
}

/* Cloud Popup for Bone Info */
.bone-info-popup {
  position: absolute;
  background: rgba(29,41,77,0.95);
  color: #fff;
  padding: 16px 20px;
  border-radius: 20px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.4);
  backdrop-filter: blur(10px);
  max-width: 280px;
  z-index: 100;
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
  pointer-events: none;
  right: 40px;
  top: 50%;
  margin-top: -100px;
  transform: scale(0);
  transform-origin: right center;
}

.bone-info-popup.visible {
  opacity: 1;
  transform: scale(1);
}

.bone-info-popup::before {
  content: '';
  position: absolute;
  top: 50%;
  right: -8px;
  transform: translateY(-50%);
  width: 0;
  height: 0;
  border-top: 10px solid transparent;
  border-bottom: 10px solid transparent;
  border-left: 8px solid rgba(29,41,77,0.95);
}

.popup-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
}

.popup-icon {
  font-size: 1.8em;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}

.popup-title {
  font-size: 1.1em;
  font-weight: 600;
  color: #ffd166;
  margin: 0;
}

.popup-function {
  font-size: 0.9em;
  line-height: 1.4;
  color: #f4f7ff;
  margin: 0 0 12px;
}

.popup-functions {
  background: rgba(12, 28, 68, 0.4);
  padding: 12px;
  border-radius: 12px;
}

.popup-functions h4 {
  margin: 0 0 8px;
  font-size: 0.85em;
  color: #ffd166;
  display: flex;
  align-items: center;
  gap: 6px;
}

.popup-function-item {
  font-size: 0.8em;
  line-height: 1.3;
  color: #e2e8f0;
  margin: 4px 0;
  padding-left: 8px;
  position: relative;
}

.popup-function-item::before {
  content: 'â€¢';
  position: absolute;
  left: 0;
  color: #ffd166;
}

/* Bottom Fun Facts Bar */
#bottom-bar {
  background: linear-gradient(90deg, rgba(29,41,77,0.95), rgba(33,64,95,0.9));
  color: #fff;
  padding: 16px 24px;
  box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
  min-height: 60px;
}

.fun-fact-content {
  display: flex;
  align-items: center;
  gap: 16px;
}

.fun-fact-icon {
  font-size: 2em;
  filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
}

.fun-fact-text {
  flex: 1;
}

.fun-fact-text h3 {
  margin: 0 0 4px;
  color: #ffd166;
  font-size: 1.1em;
}

.fun-fact-text p {
  margin: 0;
  font-size: 0.95em;
  line-height: 1.4;
  color: #f4f7ff;
}

.hidden { display: none; }
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
    "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/GLTFLoader.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js"
  }
}
</script>
</head>
<body>
<div id="main-container">
  <div id="sidebar">
    <h3>ğŸ” Jelajahi Tulang</h3>
    <input type="text" id="search-box" placeholder="Cari nama tulang...">
    
    <div class="category-group">
      <div class="category-title">ğŸ‘¤ Kepala & Leher</div>
      <ul class="bone-list">
        <li class="bone-item" data-bone="Tengkorak">ğŸ§  Tengkorak</li>
        <li class="bone-item" data-bone="Rahang_Bawah">ğŸ¦· Rahang Bawah</li>
        <li class="bone-item" data-bone="Tulang_Leher">ğŸ—¼ Tulang Leher</li>
      </ul>
    </div>

    <div class="category-group">
      <div class="category-title">ğŸ’ª Lengan & Tangan</div>
      <ul class="bone-list">
        <li class="bone-item" data-bone="Tulang_Lengan_Atas">ğŸ’ª Lengan Atas</li>
        <li class="bone-item" data-bone="Tulang_Hasta">ğŸ¦´ Tulang Hasta</li>
        <li class="bone-item" data-bone="Tulang_Pengumpil">ğŸ”„ Tulang Pengumpil</li>
        <li class="bone-item" data-bone="Tulang_Telapak_Tangan">ğŸ‘ Telapak Tangan</li>
        <li class="bone-item" data-bone="Tulang_Jari_Tangan">âœ‹ Jari Tangan</li>
      </ul>
    </div>

    <div class="category-group">
      <div class="category-title">ğŸƒ Kaki & Tungkai</div>
      <ul class="bone-list">
        <li class="bone-item" data-bone="Tulang_Paha">ğŸ¦µ Tulang Paha</li>
        <li class="bone-item" data-bone="Tulang_Tempurung_Lutut">ğŸ”˜ Tempurung Lutut</li>
        <li class="bone-item" data-bone="Tulang_Kering">ğŸ“ Tulang Kering</li>
        <li class="bone-item" data-bone="Tulang_Betis">ğŸ¦´ Tulang Betis</li>
        <li class="bone-item" data-bone="Tulang_Jari_Kaki">ğŸ¦¶ Jari Kaki</li>
      </ul>
    </div>

    <div class="category-group">
      <div class="category-title">ğŸ—ï¸ Tubuh & Punggung</div>
      <ul class="bone-list">
        <li class="bone-item" data-bone="Tulang_Belakang">ğŸ Tulang Belakang</li>
        <li class="bone-item" data-bone="Tulang_Rusuk">ğŸ« Tulang Rusuk</li>
        <li class="bone-item" data-bone="Tulang_Panggul">âšª Tulang Panggul</li>
        <li class="bone-item" data-bone="Tulang_Belikat">ğŸ›¡ï¸ Tulang Belikat</li>
        <li class="bone-item" data-bone="Tulang_Selangka">â– Tulang Selangka</li>
      </ul>
    </div>
  </div>

  <div id="canvas-container">
    <div id="bone-popup" class="bone-info-popup">
      <!-- Content will be populated by JavaScript -->
    </div>
  </div>
</div>

<div id="bottom-bar">
  <div class="fun-fact-content">
    <div class="fun-fact-icon">ğŸ’¡</div>
    <div class="fun-fact-text">
      <h3 id="fun-fact-title">Tahukah Kamu?</h3>
      <p id="fun-fact-content">Pilih bagian tulang untuk melihat fakta menarik tentang tulangmu!</p>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0,1.5,3);

const canvasContainer = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
canvasContainer.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.target.set(0,1,0);
controls.update();

// Lights
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
hemiLight.position.set(0, 20, 0);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(5, 10, 7.5);
dirLight.castShadow = true;
scene.add(dirLight);

const rimPositions = [
  [3, 2, 2], [-3, 2, 2], [3, 2, -2], [-3, 2, -2]
];
rimPositions.forEach(pos => {
  const rim = new THREE.DirectionalLight(0xffffff, 0.8);
  rim.position.set(...pos);
  scene.add(rim);
});

// Load model
const loader = new GLTFLoader();
let modelRoot;
loader.load('./kerangka.glb', 
  // Success callback
  gltf => {
    modelRoot = gltf.scene;
    modelRoot.position.set(0,-1,0);
    scene.add(modelRoot);

    modelRoot.traverse(node => {
      if(node.isMesh){
        if (!node.userData.originalScale) {
          node.userData.originalScale = node.scale.clone();
        }
        console.log('Mesh found:', node.name);
        
        // Add raycast layers for better detection
        node.raycast = THREE.Mesh.prototype.raycast;
      }
    });
    
    console.log('Model loaded successfully');
    console.log('All mesh names:', getAllMeshNames());
  },
  // Progress callback
  progress => {
    console.log('Loading progress:', (progress.loaded / progress.total * 100) + '%');
  },
  // Error callback
  error => {
    console.error('Error loading model:', error);
    console.log('Make sure kerangka.glb file exists in the same folder as index.html');
    
    // Add a simple cube as fallback for testing
    const geometry = new THREE.BoxGeometry(1, 2, 0.5);
    const material = new THREE.MeshLambertMaterial({ color: 0xcccccc });
    const cube = new THREE.Mesh(geometry, material);
    cube.name = 'Tengkorak';
    cube.position.set(0, 0, 0);
    scene.add(cube);
    
    // Store as modelRoot for testing
    modelRoot = new THREE.Group();
    modelRoot.add(cube);
    cube.userData.originalScale = cube.scale.clone();
    console.log('Fallback cube added for testing');
  }
);

// Enhanced messages with functions and fun facts
const messages = {
  "Rahang_Bawah": {
    name:"Rahang Bawah", 
    function:"Menggigit dan mengunyah makanan dengan kekuatan hingga 70 kg per cmÂ²",
    functions: ["Menggigit makanan keras", "Mengunyah dan menghaluskan makanan", "Membantu berbicara dan artikulasi", "Memberikan bentuk pada wajah bagian bawah"],
    funfact:"Rahang manusia bisa menggigit dengan kekuatan 200 pon per inci persegi - lebih kuat dari gigitan singa!"
  },
  "Tengkorak": {
    name:"Tengkorak", 
    function:"Melindungi otak dan organ sensorik dari benturan dan cedera",
    functions: ["Melindungi otak dari trauma", "Menopang organ sensorik (mata, telinga, hidung)", "Memberikan struktur wajah", "Melindungi pembuluh darah otak"],
    funfact:"Tengkorak bayi memiliki celah lunak yang disebut fontanel, yang memungkinkan otak tumbuh pesat dalam 2 tahun pertama!"
  },
  "Tulang_Belakang": {
    name:"Tulang Belakang", 
    function:"Menopang tubuh dan melindungi sumsum tulang belakang",
    functions: ["Menopang berat tubuh", "Melindungi sumsum tulang belakang", "Memungkinkan gerakan fleksibel", "Menyangga kepala dan organ dalam"],
    funfact:"Tulang belakang memiliki 4 lengkungan alami yang berfungsi seperti pegas untuk menyerap guncangan saat berjalan!"
  },
  "Tulang_Paha": {
    name:"Tulang Paha", 
    function:"Menopang seluruh berat tubuh dan memungkinkan gerakan berjalan",
    functions: ["Menopang berat tubuh saat berdiri", "Memungkinkan gerakan berjalan dan berlari", "Mentransfer beban ke tulang kaki", "Tempat menempel otot paha yang kuat"],
    funfact:"Tulang paha adalah tulang terpanjang dan terkuat - bisa menahan tekanan hingga 1.800-2.500 pon!"
  },
  "Tulang_Belikat": {name:"Tulang Belikat", function:"Menghubungkan lengan dengan tubuh", functions: ["Menopang lengan", "Memungkinkan gerakan bahu"], funfact:"Tulang belikat dapat bergerak dalam 6 arah berbeda!"},
  "Tulang_Betis": {name:"Tulang Betis", function:"Menopang berat tubuh dan membantu keseimbangan", functions: ["Menopang tubuh", "Membantu keseimbangan"], funfact:"Tulang betis lebih tipis dari tulang kering tapi sangat fleksibel!"},
  "Tulang_Hasta": {name:"Tulang Hasta", function:"Memungkinkan pergerakan lengan bawah dan pergelangan tangan", functions: ["Gerakan lengan bawah", "Rotasi pergelangan"], funfact:"Tulang hasta membantu kita memutar telapak tangan!"},
  "Tulang_Jari_Kaki": {name:"Tulang Jari Kaki", function:"Mendukung keseimbangan dan membantu berjalan", functions: ["Keseimbangan", "Dorongan saat berjalan"], funfact:"Jari kaki besar menahan 40% berat tubuh saat berjalan!"},
  "Tulang_Jari_Tangan": {name:"Tulang Jari Tangan", function:"Memungkinkan gerakan presisi dan memegang benda", functions: ["Gerakan presisi", "Menggenggam"], funfact:"Tangan manusia memiliki 27 tulang kecil!"},
  "Tulang_Kering": {name:"Tulang Kering", function:"Menopang tubuh dan menjaga kestabilan saat bergerak", functions: ["Menopang tubuh", "Stabilitas"], funfact:"Tulang kering adalah tulang terkuat kedua setelah tulang paha!"},
  "Tulang_Leher": {name:"Tulang Leher", function:"Mendukung kepala dan memungkinkan rotasi", functions: ["Menopang kepala", "Rotasi leher"], funfact:"Leher manusia memiliki 7 ruas tulang belakang!"},
  "Tulang_Lengan_Atas": {name:"Tulang Lengan Atas", function:"Menghubungkan bahu dan siku", functions: ["Gerakan lengan", "Kekuatan angkat"], funfact:"Tulang lengan atas sangat kuat dan bisa menahan beban hingga 300kg!"},
  "Tulang_Panggul": {name:"Tulang Panggul", function:"Menopang tubuh bagian atas dan menahan organ dalam", functions: ["Menopang tubuh atas", "Melindungi organ"], funfact:"Panggul wanita lebih lebar dari pria untuk memudahkan persalinan!"},
  "Tulang_Pengumpil": {name:"Tulang Pengumpil", function:"Memungkinkan rotasi lengan bawah", functions: ["Rotasi lengan", "Gerakan pergelangan"], funfact:"Tulang pengumpil bekerja sama dengan tulang hasta untuk memutar lengan!"},
  "Tulang_Pergelangan_Kaki": {name:"Tulang Pergelangan Kaki", function:"Memungkinkan gerakan fleksibel sambil menopang tubuh", functions: ["Fleksibilitas kaki", "Menopang tubuh"], funfact:"Pergelangan kaki menahan beban 5x berat tubuh saat berlari!"},
  "Tulang_Rusuk": {name:"Tulang Rusuk", function:"Melindungi jantung dan paru-paru", functions: ["Melindungi organ vital", "Membantu pernapasan"], funfact:"Manusia memiliki 24 tulang rusuk - 12 pasang!"},
  "Tulang_Selangka": {name:"Tulang Selangka", function:"Menghubungkan lengan dengan tubuh", functions: ["Menghubungkan lengan-tubuh", "Stabilitas bahu"], funfact:"Tulang selangka adalah tulang pertama yang mengeras saat bayi!"},
  "Tulang_Telapak_Tangan": {name:"Tulang Telapak Tangan", function:"Mendukung gerakan jari dan pegangan tangan", functions: ["Menopang jari", "Pegangan kuat"], funfact:"Telapak tangan memiliki lengkungan yang membantu menggenggam!"},
  "Tulang_Tempurung_Lutut": {name:"Tulang Tempurung Lutut", function:"Melindungi sendi lutut", functions: ["Melindungi lutut", "Membantu gerakan kaki"], funfact:"Tempurung lutut adalah tulang sesamoid terbesar dalam tubuh!"}
};

// Raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const bonePopup = document.getElementById('bone-popup');
const defaultInfo = {
  title: 'Pilih Tulang Favoritmu!',
  text: 'ğŸ–±ï¸ Klik bagian tubuh untuk melihat fungsi tulang.'
};
let highlightedMesh = null;
let previousMaterial = null;
let pulsingMesh = null;
const focusState = {
  active: false,
  start: 0,
  duration: 750,
  fromCam: new THREE.Vector3(),
  toCam: new THREE.Vector3(),
  fromTarget: new THREE.Vector3(),
  toTarget: new THREE.Vector3()
};

function disposeMaterial(mat) {
  if (Array.isArray(mat)) {
    mat.forEach(m => m.dispose());
  } else {
    mat.dispose();
  }
}

function cloneHighlightedMaterial(mat) {
  if (Array.isArray(mat)) {
    return mat.map(cloneHighlightedMaterial);
  }
  const clone = mat.clone();
  if (clone.color) clone.color.set(0xffff66);
  if (clone.emissive) clone.emissive.setHex(0x333300);
  return clone;
}

// Show popup cloud with bone info
function showBonePopup(mesh, screenPos) {
  const msg = messages[mesh.name];
  if (!msg) {
    console.log('No message found for:', mesh.name);
    return;
  }

  console.log('Showing popup for:', mesh.name);
  
  // First, ensure popup is hidden and reset
  bonePopup.classList.remove('visible');
  
  // Small delay to ensure transition triggers
  setTimeout(() => {
    bonePopup.innerHTML = `
      <div class="popup-header">
        <div class="popup-icon">ğŸ¦´</div>
        <h3 class="popup-title">${msg.name}</h3>
      </div>
      <p class="popup-function">${msg.function}</p>
      <div class="popup-functions">
        <h4>âš™ï¸ Fungsi Utama:</h4>
        ${msg.functions.map(func => `<div class="popup-function-item">${func}</div>`).join('')}
      </div>
    `;

    // Force reflow to ensure transition happens
    void bonePopup.offsetWidth;
    
    // Show popup - stays visible until another bone is clicked or ESC is pressed
    bonePopup.classList.add('visible');
  }, 10);
  
  // Removed auto-hide timeout - popup stays visible
}

function hidePopup() {
  bonePopup.classList.remove('visible');
}

function resetHighlight() {
  if (!highlightedMesh) {
    updateBottomBar();
    return;
  }
  if (previousMaterial) {
    disposeMaterial(highlightedMesh.material);
    highlightedMesh.material = previousMaterial;
  }
  if (highlightedMesh.userData.originalScale) {
    highlightedMesh.scale.copy(highlightedMesh.userData.originalScale);
  }
  highlightedMesh = null;
  previousMaterial = null;
  pulsingMesh = null;
  hidePopup();
  updateBottomBar();
}

function focusOnMesh(mesh) {
  const box = new THREE.Box3().setFromObject(mesh);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const radius = size.length() * 0.5;
  const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
  const distance = THREE.MathUtils.clamp(radius * 1.4, 0.7, 2.2);
  const newCameraPos = center.clone().add(direction.multiplyScalar(distance));

  focusState.fromCam.copy(camera.position);
  focusState.toCam.copy(newCameraPos);
  focusState.fromTarget.copy(controls.target);
  focusState.toTarget.copy(center);
  focusState.start = performance.now();
  focusState.active = true;
}

function highlightMesh(mesh, clickPos = null) {
  resetHighlight();
  highlightedMesh = mesh;
  previousMaterial = mesh.material;
  mesh.material = cloneHighlightedMaterial(previousMaterial);
  pulsingMesh = mesh;
  mesh.userData.pulseStart = performance.now();

  const msg = messages[mesh.name];
  if (msg) {
    updateBottomBar(`Fun Fact: ${msg.name}`, msg.funfact);
    if (clickPos) showBonePopup(mesh, clickPos);
  } else {
    updateBottomBar('Fun Fact', 'Setiap tulang memiliki peran penting dalam tubuh kita!');
  }

  // Track learning
  if (mesh.name) learnedBones.add(mesh.name);
  
  // Update sidebar active state
  document.querySelectorAll('.bone-item').forEach(item => {
    item.classList.toggle('active', item.dataset.bone === mesh.name);
  });

  focusOnMesh(mesh);
}

// Update bottom bar with fun facts
function updateBottomBar(title = "Tahukah Kamu?", content = "Pilih bagian tulang untuk melihat fakta menarik tentang tulangmu!") {
  const titleElement = document.getElementById('fun-fact-title');
  const contentElement = document.getElementById('fun-fact-content');
  if (titleElement) titleElement.textContent = title;
  if (contentElement) contentElement.textContent = content;
}

// Helper function to get all mesh names
function getAllMeshNames() {
  if (!modelRoot) return [];
  const names = [];
  modelRoot.traverse(node => {
    if (node.isMesh && node.name) {
      names.push(node.name);
    }
  });
  return names;
}

// Improved raycaster with recursive search and name matching
function findBestMatch(meshName) {
  const cleanName = meshName.toLowerCase().replace(/[_\s.-]/g, '');
  
  // Direct match
  if (messages[meshName]) return meshName;
  
  // Try to find partial matches
  for (const key in messages) {
    const cleanKey = key.toLowerCase().replace(/[_\s.-]/g, '');
    if (cleanName.includes(cleanKey) || cleanKey.includes(cleanName)) {
      console.log(`Matched ${meshName} to ${key}`);
      return key;
    }
  }
  
  // Special cases for common variations
  const mappings = {
    'humerus': 'Tulang_Lengan_Atas',
    'ulna': 'Tulang_Hasta',
    'radius': 'Tulang_Pengumpil',
    'carpal': 'Tulang_Telapak_Tangan',
    'metacarpal': 'Tulang_Telapak_Tangan',
    'phalanges': 'Tulang_Jari_Tangan',
    'finger': 'Tulang_Jari_Tangan',
    'hand': 'Tulang_Telapak_Tangan',
    'arm': 'Tulang_Lengan_Atas',
    'forearm': 'Tulang_Hasta'
  };
  
  for (const [pattern, bone] of Object.entries(mappings)) {
    if (cleanName.includes(pattern)) {
      console.log(`Pattern matched ${meshName} to ${bone}`);
      return bone;
    }
  }
  
  return null;
}

// Raycaster click event
function onClick(event){
  console.log('Click detected at:', event.clientX, event.clientY);
  if (!modelRoot) {
    console.log('Model not loaded yet');
    return;
  }
  
  mouse.x = (event.clientX / window.innerWidth)*2 - 1;
  mouse.y = -(event.clientY / window.innerHeight)*2 + 1;
  raycaster.setFromCamera(mouse, camera);

  // Increase raycaster precision for smaller bones
  raycaster.params.Mesh.threshold = 0.1;
  
  const intersects = raycaster.intersectObject(modelRoot, true);
  console.log('Intersects found:', intersects.length);
  
  if(intersects.length>0){
    const mesh = intersects[0].object;
    console.log('Clicked mesh name:', mesh.name);
    console.log('Clicked mesh type:', mesh.type);
    
    if(!mesh.isMesh) {
      console.log('Not a mesh, skipping');
      return;
    }
    
    // Try to find matching bone name
    const matchedName = findBestMatch(mesh.name);
    if (matchedName) {
      // Temporarily set the matched name for display
      const originalName = mesh.name;
      mesh.name = matchedName;
      highlightMesh(mesh, { x: event.clientX, y: event.clientY });
      // Store original name for reference
      mesh.userData.originalName = originalName;
    } else {
      console.log('No matching message found for mesh:', mesh.name);
      console.log('Available bones:', Object.keys(messages));
      // Still highlight but show generic message
      highlightMesh(mesh, { x: event.clientX, y: event.clientY });
    }
  } else {
    console.log('No intersects found');
  }
}

window.addEventListener('click', onClick);

window.addEventListener('keydown', e=>{
  if(e.key==='Escape'){
    resetHighlight();
  }
});

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

function animate(){
  requestAnimationFrame(animate);

  if (focusState.active) {
    const progress = Math.min((performance.now() - focusState.start) / focusState.duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    camera.position.lerpVectors(focusState.fromCam, focusState.toCam, eased);
    controls.target.lerpVectors(focusState.fromTarget, focusState.toTarget, eased);
    if (progress >= 1) {
      focusState.active = false;
    }
  }

  if (pulsingMesh && pulsingMesh.userData.originalScale) {
    const elapsed = (performance.now() - pulsingMesh.userData.pulseStart) / 1000;
    const factor = 1 + 0.05 * Math.sin(elapsed * Math.PI * 2);
    const originalScale = pulsingMesh.userData.originalScale;
    pulsingMesh.scale.set(
      originalScale.x * factor,
      originalScale.y * factor,
      originalScale.z * factor
    );
  }

  controls.update();
  renderer.render(scene,camera);
}
animate();

// Sidebar interaction
document.querySelectorAll('.bone-item').forEach(item => {
  item.addEventListener('click', () => {
    const boneName = item.dataset.bone;
    // Remove active from all items
    document.querySelectorAll('.bone-item').forEach(i => i.classList.remove('active'));
    // Add active to clicked item
    item.classList.add('active');
    
    // Find and highlight the bone in 3D model
    if (modelRoot) {
      let mesh = modelRoot.getObjectByName(boneName);
      
      // If not found, try to find by matching
      if (!mesh) {
        modelRoot.traverse(node => {
          if (node.isMesh && !mesh) {
            const matchedName = findBestMatch(node.name);
            if (matchedName === boneName) {
              mesh = node;
              // Set the matched name for display
              mesh.userData.originalName = mesh.name;
              mesh.name = matchedName;
            }
          }
        });
      }
      
      if (mesh) {
        highlightMesh(mesh, { x: window.innerWidth / 2, y: window.innerHeight / 2 });
      }
    }
  });
});

// Search functionality
document.getElementById('search-box').addEventListener('input', (e) => {
  const search = e.target.value.toLowerCase();
  document.querySelectorAll('.bone-item').forEach(item => {
    const text = item.textContent.toLowerCase();
    item.style.display = text.includes(search) ? 'flex' : 'none';
  });
});

// Study time counter - remove references to non-existent elements
let studyStartTime = Date.now();
let learnedBones = new Set();

function updateStats() {
  const elapsed = Math.floor((Date.now() - studyStartTime) / 1000);
  const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
  const seconds = (elapsed % 60).toString().padStart(2, '0');
  
  // Only update if elements exist
  const studyTimeElement = document.getElementById('study-time');
  const learnedCountElement = document.getElementById('learned-count');
  
  if (studyTimeElement) studyTimeElement.textContent = `${minutes}:${seconds}`;
  if (learnedCountElement) learnedCountElement.textContent = learnedBones.size;
}

setInterval(updateStats, 1000);
</script>
</body>
</html>
