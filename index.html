<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kerangka 3D Interaktif</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
<style>
body {
  margin: 0;
  font-family: 'Fredoka', Arial, sans-serif;
  display: flex;
  height: 100vh;
  background: linear-gradient(135deg, rgba(84,141,255,0.35), rgba(255,183,77,0.25)) no-repeat fixed, url('./background.png') no-repeat center center fixed;
  background-size: cover;
}

/* Container kiri untuk 3D */
#canvas-container {
  flex: 8; /* 80% lebar */
  position: relative;
  overflow: hidden;
  border-top-right-radius: 24px;
  border-bottom-right-radius: 24px;
  box-shadow: inset 0 0 30px rgba(0,0,0,0.25);
}

/* Judul di kiri atas */
#left-title {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #fff;
  font-size: 2.5em;
  font-weight: bold;
  background: rgba(0,0,0,0.5);
  padding: 5px 10px;
  border-radius: 5px;
  z-index: 5;
  letter-spacing: 1px;
  text-shadow: 0 3px 12px rgba(0,0,0,0.45);
}

/* Petunjuk kontrol di kiri bawah */
#controls-info {
  position: absolute;
  bottom: 10px;
  left: 10px;
  color: #fff;
  background: rgba(0,0,0,0.5);
  padding: 8px 10px;
  border-radius: 12px;
  backdrop-filter: blur(6px);
  font-size: 0.9em;
  z-index: 5;
}

#controls-info::before {
  content: "üïπÔ∏è ";
  font-size: 1.1em;
}

/* Panel kanan untuk funfact */
#info-panel {
  flex: 2; /* 20% lebar */
  background: linear-gradient(180deg, rgba(29,41,77,0.95), rgba(33,64,95,0.9));
  color: #fff;
  padding: 28px 24px;
  overflow-y: auto;
  border-radius: 24px 0 0 24px;
  box-shadow: -10px 0 24px rgba(0,0,0,0.35);
}

.info-card {
  display: flex;
  align-items: flex-start;
  gap: 16px;
  background: rgba(12, 28, 68, 0.65);
  padding: 18px 20px;
  border-radius: 18px;
  box-shadow: inset 0 0 12px rgba(255,255,255,0.05);
}
.info-card h2 {
  margin: 0 0 8px;
  font-size: 1.3em;
  color: #ffd166;
}
.info-card p {
  margin: 0;
  font-size: 1.05em;
  line-height: 1.7;
  color: #f4f7ff;
}
.info-icon {
  font-size: 2.2em;
  filter: drop-shadow(0 4px 6px rgba(0,0,0,0.35));
}
.info-text {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
</style>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
    "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/loaders/GLTFLoader.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/controls/OrbitControls.js"
  }
}
</script>
</head>
<body>
<div id="canvas-container">
  <div id="left-title">Kerangka Tubuh Manusia</div>
  <div id="controls-info">
    Kontrol: <br>
    - Geser mouse untuk putar <br>
    - Scroll untuk zoom <br>
    - Klik tulang untuk info <br>
    - ESC untuk reset highlight
  </div>
</div>

<div id="info-panel">
  <h2>Fun Fact Tulang</h2>
  <p>Klik bagian tulang untuk info</p>
</div>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0,1.5,3);

const canvasContainer = document.getElementById('canvas-container');
const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
canvasContainer.appendChild(renderer.domElement);

// Controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.target.set(0,1,0);
controls.update();

// Lights
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
hemiLight.position.set(0, 20, 0);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
dirLight.position.set(5, 10, 7.5);
dirLight.castShadow = true;
scene.add(dirLight);

const rimPositions = [
  [3, 2, 2], [-3, 2, 2], [3, 2, -2], [-3, 2, -2]
];
rimPositions.forEach(pos => {
  const rim = new THREE.DirectionalLight(0xffffff, 0.8);
  rim.position.set(...pos);
  scene.add(rim);
});

// Load model
const loader = new GLTFLoader();
let modelRoot;
loader.load('./kerangka.glb', gltf => {
  modelRoot = gltf.scene;
  modelRoot.position.set(0,-1,0);
  scene.add(modelRoot);

  modelRoot.traverse(node => {
    if(node.isMesh){
      if (!node.userData.originalScale) {
        node.userData.originalScale = node.scale.clone();
      }
      console.log(node.name);
    }
  });
});

// Messages
const messages = {
  "Rahang_Bawah": {name:"Rahang Bawah", funfact:"Rahang bawah adalah tulang kuat yang berfungsi untuk menggigit dan mengunyah makanan."},
  "Tengkorak": {name:"Tengkorak", funfact:"Tengkorak melindungi otak dan membentuk struktur wajah."},
  "Tulang_Belakang": {name:"Tulang Belakang", funfact:"Tulang belakang menopang tubuh dan melindungi sumsum tulang belakang."},
  "Tulang_Belikat": {name:"Tulang Belikat", funfact:"Tulang belikat menghubungkan lengan dengan tubuh."},
  "Tulang_Betis": {name:"Tulang Betis", funfact:"Tulang betis menopang berat tubuh dan membantu keseimbangan."},
  "Tulang_Hasta": {name:"Tulang Hasta", funfact:"Tulang hasta memungkinkan pergerakan lengan bawah dan pergelangan tangan."},
  "Tulang_Jari_Kaki": {name:"Tulang Jari Kaki", funfact:"Tulang jari kaki mendukung keseimbangan dan membantu berjalan."},
  "Tulang_Jari_Tangan": {name:"Tulang Jari Tangan", funfact:"Tulang jari tangan memungkinkan gerakan presisi dan memegang benda."},
  "Tulang_Kering": {name:"Tulang Kering", funfact:"Tulang kering menopang tubuh dan menjaga kestabilan saat bergerak."},
  "Tulang_Leher": {name:"Tulang Leher", funfact:"Tulang leher mendukung kepala dan memungkinkan rotasi."},
  "Tulang_Lengan_Atas": {name:"Tulang Lengan Atas", funfact:"Tulang lengan atas menghubungkan bahu dan siku."},
  "Tulang_Paha": {name:"Tulang Paha", funfact:"Tulang paha adalah tulang terpanjang yang menopang tubuh."},
  "Tulang_Panggul": {name:"Tulang Panggul" , funfact:"Tulang panggul menopang tubuh bagian atas dan menahan organ dalam."},
  "Tulang_Pengumpil": {name:"Tulang Pengumpil", funfact:"Tulang pengumpil memungkinkan rotasi lengan bawah."},
  "Tulang_Pergelangan_Kaki": {name:"Tulang Pergelangan Kaki", funfact:"Tulang pergelangan kaki memungkinkan gerakan fleksibel sambil menopang tubuh."},
  "Tulang_Rusuk": {name:"Tulang Rusuk", funfact:"Tulang rusuk melindungi jantung dan paru-paru."},
  "Tulang_Selangka": {name:"Tulang Selangka", funfact:"Tulang selangka menghubungkan lengan dengan tubuh."},
  "Tulang_Telapak_Tangan": {name:"Tulang Telapak Tangan", funfact:"Tulang telapak tangan mendukung gerakan jari dan pegangan tangan."},
  "Tulang_Tempurung_Lutut": {name:"Tulang Tempurung Lutut", funfact:"Tulang tempurung lutut melindungi sendi lutut."}
};

// Raycaster
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const infoPanel = document.getElementById('info-panel');
const defaultInfo = {
  title: 'Pilih Tulang Favoritmu!',
  text: 'üñ±Ô∏è Klik bagian tubuh untuk melihat fakta tulang yang seru.'
};
let highlightedMesh = null;
let previousMaterial = null;
let pulsingMesh = null;
const focusState = {
  active: false,
  start: 0,
  duration: 750,
  fromCam: new THREE.Vector3(),
  toCam: new THREE.Vector3(),
  fromTarget: new THREE.Vector3(),
  toTarget: new THREE.Vector3()
};

function disposeMaterial(mat) {
  if (Array.isArray(mat)) {
    mat.forEach(m => m.dispose());
  } else {
    mat.dispose();
  }
}

function cloneHighlightedMaterial(mat) {
  if (Array.isArray(mat)) {
    return mat.map(cloneHighlightedMaterial);
  }
  const clone = mat.clone();
  if (clone.color) clone.color.set(0xffff66);
  if (clone.emissive) clone.emissive.setHex(0x333300);
  return clone;
}

function renderInfoPanel(title, fact) {
  infoPanel.innerHTML = `
    <div class="info-card">
      <div class="info-icon">ü¶¥</div>
      <div class="info-text">
        <h2>${title}</h2>
        <p>${fact}</p>
      </div>
    </div>
  `;
}

function resetHighlight() {
  if (!highlightedMesh) {
    renderInfoPanel(defaultInfo.title, defaultInfo.text);
    return;
  }
  if (previousMaterial) {
    disposeMaterial(highlightedMesh.material);
    highlightedMesh.material = previousMaterial;
  }
  if (highlightedMesh.userData.originalScale) {
    highlightedMesh.scale.copy(highlightedMesh.userData.originalScale);
  }
  highlightedMesh = null;
  previousMaterial = null;
  pulsingMesh = null;
  renderInfoPanel(defaultInfo.title, defaultInfo.text);
}

function focusOnMesh(mesh) {
  const box = new THREE.Box3().setFromObject(mesh);
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  const radius = size.length() * 0.5;
  const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
  const distance = THREE.MathUtils.clamp(radius * 1.4, 0.7, 2.2);
  const newCameraPos = center.clone().add(direction.multiplyScalar(distance));

  focusState.fromCam.copy(camera.position);
  focusState.toCam.copy(newCameraPos);
  focusState.fromTarget.copy(controls.target);
  focusState.toTarget.copy(center);
  focusState.start = performance.now();
  focusState.active = true;
}

function highlightMesh(mesh) {
  resetHighlight();
  highlightedMesh = mesh;
  previousMaterial = mesh.material;
  mesh.material = cloneHighlightedMaterial(previousMaterial);
  pulsingMesh = mesh;
  mesh.userData.pulseStart = performance.now();

  const msg = messages[mesh.name];
  if (msg) {
    renderInfoPanel(msg.name, `‚ú® ${msg.funfact}`);
  } else {
    renderInfoPanel(mesh.name || 'Tidak bernama', '‚ú® Belum ada fakta, tapi tulang ini tetap seru untuk dijelajahi!');
  }

  focusOnMesh(mesh);
}

function onClick(event){
  if (!modelRoot) return;
  mouse.x = (event.clientX / window.innerWidth)*2 - 1;
  mouse.y = -(event.clientY / window.innerHeight)*2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObject(modelRoot, true);
  if(intersects.length>0){
    const mesh = intersects[0].object;
    if(!mesh.isMesh) return;
    highlightMesh(mesh);
  }
}

window.addEventListener('click', onClick);

window.addEventListener('keydown', e=>{
  if(e.key==='Escape'){
    resetHighlight();
  }
});

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

renderInfoPanel(defaultInfo.title, defaultInfo.text);

function animate(){
  requestAnimationFrame(animate);

  if (focusState.active) {
    const progress = Math.min((performance.now() - focusState.start) / focusState.duration, 1);
    const eased = 1 - Math.pow(1 - progress, 3);
    camera.position.lerpVectors(focusState.fromCam, focusState.toCam, eased);
    controls.target.lerpVectors(focusState.fromTarget, focusState.toTarget, eased);
    if (progress >= 1) {
      focusState.active = false;
    }
  }

  if (pulsingMesh && pulsingMesh.userData.originalScale) {
    const elapsed = (performance.now() - pulsingMesh.userData.pulseStart) / 1000;
    const factor = 1 + 0.05 * Math.sin(elapsed * Math.PI * 2);
    const originalScale = pulsingMesh.userData.originalScale;
    pulsingMesh.scale.set(
      originalScale.x * factor,
      originalScale.y * factor,
      originalScale.z * factor
    );
  }

  controls.update();
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
